Методы и интерфейсы
Данное занятие рассказывает про методы и интерфейсы, записи, определяющие объекты и их поведение.

Авторы Go
https://golang.org

*Методы

В Go нет классов. Однако, вы можете определять методы для типа структуры.

_Получатель_метода_ Представлен в своем собственном перечне аргументов между ключевым словом `func` и названием метода.

.play methods/methods.go

*Методы, продолжение

Вы можете объявить метод для _любого_типа_ типа, объявленого в вашем пакете, не только для структуры.

Однако, вы не можете определить метод для типа с другого пакета (включая встроенные типы).

.play methods/methods-continued.go

*Методы с получателем по указателю

Методы могут быть соединены с именуемым типом или указателем на именуемый тип.

Мы увидели два метода `Abs`. Один для указателя типа `*Vertex`, а другой для значения типа `MyFloat`.

Есть две причины на то, чтобы использовать получатель указатель. Во-первых, чтобы небыло копирования значения для каждого вызова метода (более выгодно, если значение типа является большой структурой).
Во-вторых, чтобы метод мог изменять значение, на которое указывает получатель.

Попробуйте изменить объявления методов `Abs` и` Scale`, чтобы они использовали получатель `Vertex` вместо` *Vertex`.

Метод `Scale` не повлияет, если` v` является `Vertex`. `Scale` меняет` v`. Когда `v` является значением (не через указатель) типа, то метод получает копию `Vertex` и не имеет возможности изменить оригинальное значение.

`Abs` работает в обоих случаях. Он только читает `v`. Неважно, это оригинальное значение (через указатель), или это копия того значения.

.play methods/methods-with-pointer-receivers.go

Интерфейс

Тип интерфейса определяется набором методов.

Значение типа интерфейс может содержать любое значение, представляет данные методы.

*Примечание:* В коде примера ошибка на строке 22.
`Vertex` (значение типа) не удовлетворяет `Abser`, потому
метод `Abs` определен для `*Vertex` (указатель типа).

.play methods/interfaces.go

*Интерфейсы реализуются неявно

Тип реализует интерфейс через реализацию методов.
Не существует выраженного объявления; НЕТ ключевого слова "implements".

Неявные интерфейсы разделяют пакеты реализации от пакетов, определяющие интерфейсы - они независимы друг от друга.

Это также способствует определению точных интерфейсов, ибо вы не должны искать каждую реализацию и навешивать на нее имя этого интерфейса.

[[Http://golang.org/pkg/io/][Пакет io]] определяет `Reader` и `Writer`; вы не должны этого делать.

.play methods/interfaces-are-satisfied-implicitly.go

*Stringer

Одним из самых повсеместных интерфейсов является [[//golang.org/pkg/fmt/#Stringer][`Stringer`]], определенный в пакете [[//golang.org/pkg/fmt/][`fmt`]] .

type Stringer interface {
String ()string
}

`Stringer` - это тип, который может быть представлен строкой. Пакет `fmt`
(И многие другие) требуют этот интерфейс, чтобы выводить значения.

.play methods/stringer.go

Упражнение: Stringer

Заставьте `IPAddr` реализовать `fmt.Stringer`, чтобы выводить адрес как
четверку чисел с точками.

Например, `IPAddr {1,` 2, `3,` 4}` будет выводиться как `"1.2.3.4"`.

.play methods/exercise-stringer.go

Ошибки

Программы Go выражают состояние ошибки с помощью значений `error`.

Тип `error` является встроенным интерфейсом похожим на `fmt.Stringer`:

type error interface {
Error () string
}

(Подобно `fmt.Stringer`, пакет `fmt` ожидает интерфейс `error`, когда выводит значения.)

Функции часто возвращают значение `error`. Код должен обрабатывать ошибки, проверяя равна ли ошибка `nil`.



Nil `error` означает успех; НЕ nil `error` означает неудачу.

.play methods/errors.go

Упражнение: Ошибки

Скопируйте вашу функцию `Sqrt` с [[/flowcontrol/8][предыдущего упражнения]] и измените ее, чтобы она возвращала значение `error`.

`Sqrt` должна возвращать не nil в качестве значения ошибки, когда получает отрицательное число, поскольку она не поддерживает комплексные числа.

Создайте новый тип

type ErrNegativeSqrt float64

и сделайте его типом `error`, предоставив ему

func (e ErrNegativeSqrt) Error () string

метод, чтобы `ErrNegativeSqrt(-2).Error()` возвращал `"cannot`Sqrt`negative`number: `2"`.

*Примечание:* вызов `fmt.Sprint(e)` внутри метода `Error` отправит программу к бесконечному циклу.
Этому можно помешать, если сначала преобразовать `e`:`fmt.Sprint(float64(e))`. Почему?

Измените вашу функцию `Sqrt`, чтобы она возвращала значение `ErrNegativeSqrt`, когда получает отрицательное число.

.play methods/exercise-errors.go

*Reader

Пакет `io` использует интерфейс `io.Reader`,
который представляет то, что касается чтения потока данных.

Стандартная библиотека Go содержит [[https://golang.org/search?q=Read#Global][много реализаций]] данных интерфейсов, работу с файлами, сетевыми соединениями, сжатием, шифрованием и тому подобное.

Интерфейс `io.Reader` имеет метод `Read`:

func (T) Read(b [] byte) (n int, err error)

`Read` наполняет данным полученный срез байтов и возвращает число наполненных байтов
и значение ошибки. Она возвращает ошибку `io.EOF`, когда поток заканчивается.

Код примера создает [[//golang.org/pkg/strings/#Reader][`Strings.Reader`]]. и потребляет свой вывод по 8 байтов за раз.

.play methods/reader.go

Упражнение: Reader

Реализуйте тип `Reader`, распространяющий бесконечный поток символа ASCII `'A'`.

.play methods/exercise-reader.go

Упражнение: rot13Reader

Распространенным образцом является [[https://golang.org/pkg/io/#Reader][io.Reader]], оборачивающий другой `io.Reader`, изменяя поток каким-то образом.

Например, функция [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] принимает `io.Reader` (поток сжатых данных) и возвращает `*gzip.Reader`, что также реализует `io.Reader` (поток восстановленных данных).

Создайте `rot13Reader`, реализует `io.Reader` и считывает с `io.Reader`, изменяя поток с помощью [[https://en.wikipedia.org/wiki/ROT13][rot13]], шифр подстановки ко всем символов алфавита.

Тип `rot13Reader` уже предоставлен.
Сделайте его `io.Reader`, реализовав метод` Read`.

.play methods/exercise-rot-reader.go

Веб-серверы

[[Https://golang.org/pkg/net/http/][Пакет http]] обслуживает запросы HTTP с помощью любого значения, реализует `http.Handler`:

package http

type Handler interface {
ServeHTTP (w ResponseWriter, r * Request)
}

В данном примере, тип `Hello` реализует `http.Handler`.

Откройте [[http://localhost:4000/][http://localhost:4000/]], чтобы увидеть приветствие.

#appengine *Примечание:* Данный пример не будет выполняться через интерфейс веб-тура.
#appengine Чтобы попробовать писать собственные веб-серверы
#appengine: [[https://golang.org/doc/install/][Установите Go]].

.play methods/web-servers.go

Упражнение: Обработка HTTP

Реализуйте следующие типы и определите для них методы ServeHTTP. Зарегистрируйте их для определенных адресов вашего веб-сервера.

type String string

type Struct struct {
Greeting string
Punct string
Who string
}

Например, вы можете зарегистрировать обработчики так:

http.Handle("/string", String("I'm a frayed knot."))
http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

#appengine *Примечание:* Данный пример не будет выполняться через интерфейс веб-тура.
#appengine Чтобы попробовать писать собственные веб-серверы
#appengine: [[https://golang.org/doc/install/][Установите Go]].

.play methods/exercise-http-handlers.go

Картинки

[[Https://golang.org/pkg/image/#Image][Пакет image]] определяет интерфейс `Image`:

package image

type Image interface {
ColorModel () color.Model
Bounds () Rectangle
At (x, y int) color.Color
}

*Примечание*: значение `Rectangle` результат метода `Bounds` на самом деле
[[Https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], поскольку объявление находится внутри пакета` image`.

(Смотрите [[https://golang.org/pkg/image/#Image][документацию]] для подробного изучения.)

Типы `color.Color` и `color.Model` также являются интерфейсами, но мы не будем обращать на это внимания, потому что будем использовать уже определены реализации `color.RGBA` и `color.RGBAModel`. Данные интерфейсы и типы определены в [[https://golang.org/pkg/image/color/][пакет image/color]].

.play methods/images.go

Упражнение: Изображения

Помните генератор изображений, что вы написали ранее. Давайте напишем еще один, но на этот раз он будет возвращать реализацию `image.Image` вместо среза данных.

Определите ваш собственный тип `Image`, реализующий [[https://golang.org/pkg/image/#Image][необходимые методы]], и вызовите `pic.ShowImage`.

`Bounds` должен вернуть `image.Rectangle`, похожий на `image.Rect(0,` 0, `w,` h)`.

`ColorModel` должен вернуть `color.RGBAModel`.

`At` должен вернуть цвет; значение `v` в старом генераторе изображений отвечает на `color.RGBA {v, `v,` 255, `255}` в этом.

.play methods/exercise-images.go

*Поздравляем!

Вы завершили занятие!

Вы можете вернуться к списку [[/list][занятий]], чтобы найти, что изучить дальше, или перейти к [[javascript:click('.Next-page')][следующему занятию]].
