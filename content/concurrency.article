Конкурентность
Go обеспечивает построения конкуренции, как часть ядра самого языка. Эти занятия рассказывают о них и дают примеры, как ими пользоваться.

Авторы Go
https://golang.org

* Go-подпрограммы (Goroutine)

Go-подпрограма - это легкий поток выполнения, управляемый средой Go.

    go f(x, y, z)

запускает новую go-подпрограмму, которая выполняет

    f(x, y, z)

Определение `f`,`x`,`y` и `z` происходит в текущей go-подрограме,
а выполнение `f` происходит в новой go-подпрограмме.

Go-подпрограммы выполняются в том же пространстве адресов, поэтому доступ
к общей памяти должен быть синхронизирован. Пакет [[https://golang.org/pkg/sync/][`sync`]]
предоставляет полезные примитивы, однако вам они не понадобятся так часто,
как другие примитивы Go. (Смотрите следующий слайд.)

.play concurrency/goroutines.go

* Каналы

Каналы - это труба для взаимодействия между горутинами, через которое можно
посылать и получать значения с помощью оператора канала, `<-`.

    ch <- v // Послать v к каналу ch.
    v := <-ch // Получить из ch и
    // Присвоить значение v.

(Данные идут в направлении стрелки.)

Подобно словарям и срезам, каналы должны быть созданы перед использованием:

    ch := make(chan int)

По умолчанию, отправка и получение блокируют выполнение,
пока другая сторона не готова. Это позволяет go-подпрограммам
синхронизироваться без явных блокировок или переменных состояния.

.play concurrency/channels.go

* Буферизированные каналы

Каналы могут быть буферизоваными. Чтобы инициализировать
буферизированный канал, передайте длину буфера, в качестве второго
аргумента для `make`:

    ch := make(chan int, 100)

Ссылки для буферизированного канала блокирует только тогда, когда буфер
является заполненным.

Измените пример, чтобы переполнить буфер, и посмотрите, что произойдет.

.play concurrency/buffered-channels.go

* Range и close

Отправитель может закрыть канал оператором `close`, чтобы показать,
что отправлений больше не будет. Получатели могут проверить, был ли канал закрыт,
присвоив второй параметр в выражении получения:

    v, ok := <-ch

Если значание `ok` будет `false`, тогда больше нет значений для получения, а канал закрыт.

Цикл `for`i`:=`range`c` получает значение из канала, повторяясь, пока он не будет закрыт.

*Примечание:* Только отправитель может закрыть канал. Отправка в закрытый канал вызовет ошибку.

*Еще *примечание*: Каналы отличаются от файлов; обычно у вас нет необходимости их закрывать.
Закрытие необходимо только тогда, когда получатель должен быть оповещен,
что больше значений не будет, например, для прерывания цикла `range`.

.play concurrency/range-and-close.go

* Select

Инструкция `select` позволяет go-подпрограмме ждать сразу несколько операций общения.

Инструкция `select` блокирует, пока один из каналов не может быть запущен,
тогда она выполняет этот канал.
Если несколько являются готовыми, то она случайным образом выбирает один.

.play concurrency/select.go

* Select по умолчанию

Секция `default` в `select` выполняется, если ни один другой канал не является готовым.

Пользуйтесь секцией `default`, чтобы пытаться отправлять и получать без блокировки

    select {
    case i = <-c:
    // Используем i
    default:
    // Получение с c вызвало бы блокировки
    }

.play concurrency/default-selection.go

* Упражнение: Равенство двоичных деревьев

С одного ряда значений, хранящихся как вершины, может существовать много
разных двоичных деревьев. Например, вот два двоичных дерева,
содержащих ряд 1, 1, 2, 3, 5, 8, 13.

.image /content/img/tree.png

Функция для проверки, содержат ли двоичные деревья одинаковый ряд,
довольно сложный в большинстве языков. Мы используем конкуренцию
Go и каналы, чтобы написать простое решение.

Данный пример использует пакет `tree`, что определяет тип:

    type Tree struct {
        Left *Tree
        Value int
        Right *Tree
    }

Продолжение описания на [[javascript:click('.next-page')][следующей странице]].

* Упражнение: Равенство двоичных деревьев

*1* Реализуйте функцию `Walk`.
*2* Проверьте функцию `Walk`.

Функция `tree.New(k)` строит бинарное дерево со случайной структурой,
содержит значения `k`, `2k`, `3k`..., `10k`.

Создайте новый канал `ch` и запустите обход:

    go Walk(tree.New(1), ch)

Затем прочитайте и выведите 10 значений по каналу.
Это должны быть числа 1, 2, 3, ..., 10.

*3* Реализуйте функцию `Same`, используя `Walk`, чтобы определить, `t1` и `t2`
содержат одинаковые значения.
*4* Проверьте функцию `Same`.

`Same(tree.New(1),`tree.New(1))` должна возвращать true, а `Same(tree.New(1),`tree.New(2))` должна возвращать false.

.play concurrency/exercise-equivalent-binary-trees.go

* Упражнение: Поисковый робот

В данном упражнении вы будете использовать возможности конкуренции Go
для параллелизация поискового бота.

Измените функцию `Crawl`, чтобы извлечь URL параллельно, избегая извлечения одного URL дважды.

.play concurrency/exercise-web-crawler.go

* Куда двигаться дальше...

#appengine: Вы можете начать с
#appengine: [[https://golang.org/doc/install/][Установки Go]].
#appengine: После того как установили Go,
[[Https://golang.org/doc/][Документация Go]] является прекрасным выбором для
#appengine: продолжения. Она содержит ссылки, руководства, видео и т.д.

Чтобы изучить организацию и работу с кодом Go,
посмотрите [[https://www.youtube.com/watch?v=XCsL89YtqCs][эту видеозапись]] или
прочитайте [[https://golang.org/doc/code.html][Как писать код Go]].

Если вам нужна помощь со стандартной библиотекой,
смотрите [[https://golang.org/pkg/][справочник пакетов]].
Что касается самого языка, вас может удивить читабельность [[https://golang.org/ref/spec][Спецификации языка]].

Чтобы продолжить исследование модели конкуренции Go, посмотрите
[[Https://www.youtube.com/watch?v=f6kdp27TYZs][Образцы конкуренции Go]]
([[Https://talks.golang.org/2012/concurrency.slide][слайды]])
и
[[Https://www.youtube.com/watch?v=QDDwwePbDtw][Расширенные образцы конкуренции Go]]
([[Https://talks.golang.org/2013/advconc.slide][слайды]])
и прочитайте
[[Https://golang.org/doc/codewalk/sharemem/][Совместная память через общение]].

Чтобы начать писать веб-приложения, посмотрите
[[Https://vimeo.com/53221558][Простая среда программирования]]
([[Https://talks.golang.org/2012/simple.slide][слайды]])
и изучите
[[Https://golang.org/doc/articles/wiki/][Написание веб-приложений]].

[[Https://golang.org/doc/codewalk/functions/][Функции первого класса в Go]]
представляет интересную перспективу на функциональные типы в Go.

[[Https://blog.golang.org/][Go Блог]] содержит большой архив информативных статей о Go.

Посетите [[https://golang.org][golang.org]] для получения дальнейшей информации.